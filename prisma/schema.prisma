// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// --- ENUMS ---
enum SubscriptionTier {
  FREE
  PLUS
  PRO
}

enum UserRole {
  USER
  ADMIN
}

enum PostStatus {
  PENDING
  APPROVED
  REJECTED
}

// --- MODELS ---

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  password      String?
  emailVerified DateTime?
  image         String?
  role          UserRole  @default(USER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  subscription  Subscription?
  watchlist     WatchlistItem[]
  dealDigests   DealDigestView[]
  tradePlans    TradePlan[]
  microResearch MicroResearchView[]
  blogPosts     BlogPost[]
  notes         UserNote[]
  posts         Post[]
  comments      Comment[]
  likes         Like[]

  @@map("users")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model Subscription {
  id                   String           @id @default(cuid())
  userId               String           @unique
  tier                 SubscriptionTier @default(FREE)
  status               String           // active, canceled, past_due
  stripeCustomerId     String?          @unique
  stripeSubscriptionId String?          @unique
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean          @default(false)
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  payments Payment[]

  @@index([status])
  @@index([tier])
  @@index([status, tier])
  @@map("subscriptions")
}

model Payment {
  id              String       @id @default(cuid())
  subscriptionId  String
  stripePaymentId String?      @unique
  amount          Int // in cents
  currency        String       @default("vnd")
  status          String // succeeded, pending, failed
  createdAt       DateTime     @default(now())

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@map("payments")
}

model WatchlistItem {
  id          String   @id @default(cuid())
  userId      String
  ticker      String
  companyName String
  sector      String?
  marketCap   String?
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, ticker])
  @@index([userId])
  @@index([ticker])
  @@map("watchlist_items")
}

model DealDigest {
  id               String    @id @default(cuid())
  ticker           String
  companyName      String
  sector           String
  industry         String
  marketCap        String
  pdfUrl           String?
  businessOverview String?
  financialHealth  String?
  growthCatalysts  String?
  riskFactors      String?
  riskScore        Int? // 1-10
  ifThenChecklist  String?
  metadata         Json?
  publishedAt      DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  views DealDigestView[]

  @@index([publishedAt])
  @@index([ticker])
  @@index([sector])
  @@index([industry])
  @@index([riskScore])
  @@map("deal_digests")
}

model DealDigestView {
  id           String     @id @default(cuid())
  userId       String
  dealDigestId String
  viewedAt     DateTime   @default(now())

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  dealDigest DealDigest @relation(fields: [dealDigestId], references: [id], onDelete: Cascade)

  @@unique([userId, dealDigestId], name: "userId_dealDigestId")
  @@map("deal_digest_views")
}

model TradePlan {
  id              String    @id @default(cuid())
  userId          String
  name            String
  ticker          String?
  strategy        String?
  strategyType    String?
  market          String?
  riskLevel       String? // low, medium, high
  entryPrice      Float?
  exitPrice       Float?
  targetPrice     Float?
  stopLoss        Float?
  positionSize    Float?
  riskRewardRatio Float?
  thesis          String?
  notes           String?
  status          String    @default("draft") // draft, active, closed
  flagged         Boolean   @default(false)
  flaggedReason   String?
  flaggedAt       DateTime?
  flaggedById     String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  user           User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  journalEntries TradeJournalEntry[]

  @@index([userId])
  @@index([userId, status])
  @@index([userId, updatedAt])
  @@index([ticker])
  @@index([status])
  @@index([flagged])
  @@map("trade_plans")
}

model TradeJournalEntry {
  id          String   @id @default(cuid())
  tradePlanId String
  date        DateTime
  action      String // entry, exit, adjustment
  price       Float
  quantity    Float?
  notes       String?
  createdAt   DateTime @default(now())

  tradePlan TradePlan @relation(fields: [tradePlanId], references: [id], onDelete: Cascade)

  @@map("trade_journal_entries")
}

model MicroResearch {
  id          String    @id @default(cuid())
  title       String
  ticker      String?
  companyName String?
  sector      String?
  industry    String?
  marketCap   String?
  content     String
  tags        String // JSON string array stored as text for SQLite support
  publishedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  views MicroResearchView[]

  @@index([publishedAt])
  @@index([ticker])
  @@index([sector])
  @@index([industry])
  @@map("micro_research")
}

model MicroResearchView {
  id              String   @id @default(cuid())
  userId          String
  microResearchId String
  viewedAt        DateTime @default(now())

  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  microResearch MicroResearch @relation(fields: [microResearchId], references: [id], onDelete: Cascade)

  @@unique([userId, microResearchId], name: "userId_microResearchId")
  @@map("micro_research_views")
}

model BlogPost {
  id          String    @id @default(cuid())
  title       String
  slug        String    @unique
  excerpt     String?
  content     String
  authorId    String
  published   Boolean   @default(false)
  publishedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([published, publishedAt])
  @@index([authorId])
  @@map("blog_posts")
}

model UserNote {
  id        String   @id @default(cuid())
  userId    String
  title     String
  content   String
  ticker    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_notes")
}

model Post {
  id        String     @id @default(cuid())
  title     String
  content   String
  authorId  String
  status    PostStatus @default(PENDING)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  author   User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments Comment[]
  likes    Like[]

  @@index([status])
  @@index([authorId])
  @@index([status, createdAt])
  @@map("posts")
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  postId    String
  authorId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  author User   @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([authorId])
  @@map("comments")
}

model Like {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
  @@map("likes")
}

model RiskAlert {
  id          String   @id @default(cuid())
  ticker      String
  companyName String
  alertType   String // risk_score_change, financial_warning, market_event
  message     String
  severity    String // low, medium, high, critical
  createdAt   DateTime @default(now())

  @@index([ticker])
  @@index([severity])
  @@index([createdAt])
  @@index([alertType])
  @@map("risk_alerts")
}